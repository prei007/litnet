---
title: "skosgraph design"
author: "Peter Reimann"
date: "2023-08-03"
output: html_document
---

# General idea

The app reads from a database or file one or more Skos concept schemes and offers those for coding and for expressing relations. There are two kinds of schemes:

* Nouns: Those that have classification codes, and that take a literal or code as value. Or more precisely relations data properties (relations beween resources and values). (e.g., age groups). They appear in object positions. 
* Verbs: they are relations between resources. (e.g., cito relations). They appear in predicate positions.

The user input is oriented on triples, informed by skos concepts. 

# Preparations

## Transform cito cites props into skos

Load the cito ontology and run this query:

```{sparql}
# Create skos entries for CITO cite subproperties
CONSTRUCT {
   :CitoScheme rdf:type skos:ConceptScheme .
    cito:cites rdf:type skos:Concept . 
  ?cat rdf:type skos:Concept ;
       skos:broader cito:cites ;
       skos:prefLabel ?label ;
       skos:inScheme :CitoScheme; 
       skos:definition ?comment ;
       skos:example ?desc .
  
  }
WHERE {
  ?cat rdfs:subPropertyOf cito:cites ;
       rdfs:label ?label ;
       dc:description ?desc ; 
       rdfs:comment ?comment . 
  }
```

Then download in suitable format and use as thesaurus. 

Each thesaurus should get its own namespace!

The thesauri need to use ConceptScheme and topLevel and for convenience a property `skos:depth`: 

```{RDFS}
skos:depth rdfs:subPropertyOf skos:note ;
  rdfs:label "depth" ;
  rdfs:range skos:ConceptScheme ; 
  rdfs:comment "Depth of a skos hierarchy as integer/string. For app developers convenience." .
```


# Queries

Using as example a simple methods thesaurus: `MethodsThesaurus.skos.ttl`. 

### Which thesauri are in the database?

```{sparql}
SELECT ?scheme WHERE {
     ?scheme a skos:ConceptScheme . 
}
```


### What is the depth of the thesaurus?

```{sparql}
SELECT ?d { ?scheme a skos:ConceptScheme ; 
                      skos:depth ?d }
```
e.g., "3". 

### What are the top level concepts? 

```{sparql}
SELECT ?c1 WHERE {
  ?scheme a skos:ConceptScheme . 
  ?scheme skos:hasTopConcept ?c1 . 
  }
ORDER BY ?c1
```

Yields:

```
MixedMethods 
QualitativeMethod 
QuantivativeMethod 
ResearchMethod
```

### Show all levels for one top concept

```{sparql}
SELECT ?c1 WHERE {
  ?c1 skos:broader+ rm:QualitativeMethod
  }
```

Yields: 

```
ClinicalInterview 
CaseStudyMethod 
InterviewMethod 
DocumentAnalysis 
ObservationMethod 
```

### Show second level concepts for one top level concept

```{sparql}
SELECT ?c2  WHERE {
  ?c2 skos:broader rm:QualitativeMethod
  }
```

```
ObservationMethod 
DocumentAnalysis 
InterviewMethod 
CaseStudyMethod 
```

### Is there a deeper level? 

```{sparql}
ASK WHERE {
  ?c2 skos:broader/skos:broader/skos:broader rm:QualitativeMethod
  }
```

returns false. 

### Namespace of a concept scheme

```{sparql}
SELECT ?scheme ?ns WHERE {
     ?scheme a skos:ConceptScheme . 
     ?scheme skos:hasNameSpace ?ns . 
  FILTER (?scheme IN (rm:MethodsThesaurus)) }
```

### Thesaurus for a predicate

```{sparql}
prefix litrev: <http://www.learn-web.com/2023/litrev/>
SELECT ?pred ?prop WHERE {
     ?pred a rdf:Property . 
     ?pred litrev:hasThesaurus ?prop . 
  FILTER (?pred IN (litrev:researchApproach)) }
```


# App level

The app input logic is structured around the predicates: 

1. User decides on an aspect and <selects> a predicate, such as `researchApproach`. The predicate input field needs to be observed. 
2. App <looks up> what is needed for subject and object fields: kinds of fillers and their namespaces
3. App <places> the necessary nestedMenus into the interface (or, for flat cases, updates the selectInput choice list(s))
4. User specifies statement and presses <submit>
5. App <checks> and provides where needed additional info (in a text box under the inputfields)
6. If checks okay, app <pushes> statement to server and <updates> graph and related displays. 






### Load the schemes into the app

Fetch the skos concepts ordered by scheme and store in a dataframe with two columns: 

```{sparql}
SELECT ?scheme ?concept {?scheme a skos:ConceptScheme . 
                    ?concept skos:inScheme ?scheme}
ORDER BY ?scheme 
```

We need to think conceptually about the hierarchical structure next. 

Ask for a scheme selection with `selectInput("Scheme", "Input category:", choices = skos_schemes)` and then feed the scheme concepts into a selectInput for SPO. We may want to offer, in addtion, a free text field for predicate and object. 

```{shiny}
selectInput("Scheme", "Input category:", choices = c("skos_scheme A", "skos_scheme B")),
updateTextInput() for P,O
textInput("Subject", "Subject:"),
selectInput("Predicate", "Predicate", choices = c("A", "B", "C")),
textInput("Object", "Object:"),actionButton("SubmitButton", "Submit")
```

The better approach is likely to go with a completely programmed UI for this part, so that, for instance, input categories can be displayed in flexible form. For instance, when a skos hierarchy has 3 levels, it would need 3 input fields to drill down to the lowest level. 





