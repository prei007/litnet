# concept mapping demonstration
# This is written in TRIG. 
# https://www.w3.org/TR/trig/#sec-graph-statements

@prefix : <http://example.net/> .

#### Data 1: State of matter
# Students A-C  only specify one third of the goal map. 

:StudentA {
	:Gas :condensesTo :Liquid . 
	:Liquid :boilsTo :Gas . 
}

:StudentB {
	:Solid :sublimatesTo :Gas . 
	:Gas :depositsTo :Solid. 
}

:StudentC {
	:Solid :meltsTo :Liquid . 
	:Liquid :freezesTo :Solid. 
}

# Student D knows a bit about all three but not all. 

:StudentD {
	:Gas :condensesTo :Liquid . 
	:Solid :sublimatesTo :Gas . 
	:Solid :meltsTo :Liquid .
}

# Student E added a relation that is not in the teacher graph, plus two that are. 

:StudentE {
	:Gas :condensesTo :Liquid . 
	:Solid :errorRelation :Gas . 
	:Solid :meltsTo :Liquid .
}


# The full  teacher (or goal)  model. 

:Teacher {
	:Gas :condensesTo :Liquid . 
	:Liquid :boilsTo :Gas . 
	:Solid :sublimatesTo :Gas . 
	:Gas :depositsTo :Solid.  
	:Solid :meltsTo :Liquid . 
	:Liquid :freezesTo :Solid.
}



#####################
## Queries
#####################

# show all quads

SELECT ?g ?s ?p ?o  WHERE {
   GRAPH ?g { ?s ?p ?o }  
   }
ORDER BY ?g

# Find graphs that have a specific relation.
# Based on the data above, matches A, D, and E. 

SELECT ?g  WHERE {
	GRAPH ?g {:Gas :condensesTo :Liquid.} 
 }

# Shows the graphs (if any) that do have the specified relation. 

SELECT DISTINCT ?g  WHERE {
	GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {:Gas :condensesTo :Liquid.}
      }
 }
 
## Diff between two graphs 
# Triples that are in B but not in A. 


SELECT ?s ?p ?o ?g WHERE {
   GRAPH :StudentA { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :StudentB { ?s ?p ?o }}
  }

## Errors of ommission. 
# Shows the graphs (if any) that do not have the relation. 
# This is the only way I can come up with to test for 
# omissions. The elegant of full graph comparison does not work. 
# Use case wise, this is useful for finding patterns of omissions. 

SELECT  DISTINCT ?g  WHERE {
  {GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {GRAPH ?g {:Gas :condensesTo :Liquid.}}
      }
  UNION 
  {GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {GRAPH ?g {:Solid :sublimatesTo :Gas.}}
      }
  }
  

## Diff between two graphs: Errors of commission
# Triples that are in the student map but not the teacher map
# Student E has an superfluos relation in his map. 

SELECT ?s ?p ?o ?g WHERE {
   GRAPH :StudentE { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :Teacher { ?s ?p ?o }}
  }

# generalized commission error match: 

SELECT * WHERE {
   GRAPH ?g { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :Teacher { ?s ?p ?o }}
  }

  
# If we don't care about the particular triples, we can use an ASK query to check whether any exist, without finding out what they are. For instance,

###### Scaffolding queries  


# If a student is clueless about what to link to Gas,  
# offer them a first link. 

SELECT  ?s ?p ?o  WHERE {
  {GRAPH :Teacher {  :Liquid ?p ?o }  
     BIND ("Liquid"  as ?s) 
      }

  }
LIMIT 1

# If a student is clueless about what to say about Liquid,  
# offer them all or some (use Limit) predicates. 


SELECT  ?s ?p   WHERE {
  {GRAPH :Teacher {  :Liquid ?p ?o }  
     BIND ("Liquid"  as ?s) 
      }

  }
  
# In general, the LIMIT function provides an simple way to realize 
# increasing help levels - return first 1, then 2, then all parts of 
# the normative solution. 

##### Data 2: plants

# This does not work as it does not form a proper graph. 
:Teacher {
	:T01 :proposition [:Plants :havePart :Roots] ;
		:weight "1" . 
}

# A better idea is to describe the correct network and add meta data to it. 
# The below is correct. Note that it uses RDF Reification to keep things clean. 
# https://www.w3.org/TR/rdf-schema/#ch_reificationvocab

# We want to relax this notation so that by default only P needs to be written. 
# If there's no additional meta data for any P, default values will be used in queries. 
# In particular, weight will be set to 1 as default. 


PREFIX : <http://example.net/> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 


		
:T02 :proposition :P02 ;
		:isa :Hierarchy ; 
		:weight "1" . 
:P02    rdf:subject :Plants ;
		rdf:predicate :havePart ; 
		rdf:object :Leaves . 
		
:T03 :proposition :P03 ;
		:isa :Hierarchy ; 
		:weight "1" . 
:P03 rdf:subject :Plants ;
		rdf:predicate :havePart ; 
		rdf:object :Stems . 
		
:T04 :proposition :P04 ; 
		:weight "1" . 
:P04 rdf:subject :Stems ;
		rdf:predicate :form ; 
		rdf:object :Flowers .
		
:T05 :proposition :P05 ; 
		:weight "1" . 
:P05 rdf:subject :Flowers ;
		rdf:predicate :produce ; 
		rdf:object :Seeds .
		
:T06 :proposition :P06 ; 
		:isa :BridgingRelation ; 
		:weight "2" . 
:P06 rdf:subject :Seeds ;
		rdf:predicate :store ; 
		rdf:object :Food .
		
:T07 :proposition :P07 ; 
		:weight "1" . 
:P07 rdf:subject :Flowers ;
		rdf:predicate :mayHave ; 
		rdf:object :Petals .
		
:T08 :proposition :P08 ; 
		:weight "1" . 
:P08 rdf:subject :Petals ;
		rdf:predicate :mayHave ; 
		rdf:object :Color .
		
:T09 :proposition :P09 ; 
		:weight "1". 
:P09 rdf:subject :Leaves ;
		rdf:predicate :areUsually ; 
		rdf:object :Green .
		
:T10 :proposition :P10 ; 
		:isa :BridgingRelation ;  # It's only a bridge if the Stems relation is realised. 
		:weight "2". 
:P10 rdf:subject :Leaves ;
		rdf:predicate :produce ; 
		rdf:object :Food .
		
# Student A knows little 
:StudentA {
	:Plants :havePart :Leaves . 
	:
}

# Stundent B knows a bit more
:StudentB {
	:Plants :havePart :Leaves . 
	:Plants :havePart :Roots .
	:Leaves :produce :Food .  
	:Plants :errorPredicate :errorTerm . 
}

# Student C knows much more but not everything. 
:StudentC {
	:Plants :havePart :Leaves . 
	:Plants :havePart :Roots .
	:Plants :havePart :Stems . 
	:Stems :form :Flowers . 
	:Flowers :produce :Seeds . 
	:Seeds :store :Food .  
}

# Student has some things wrong. 
:StudentD {
	:Plants :havePart :Leaves . 
	:Plants :havePart :Roots .
	:Plants :havePart :Stems . 
	:Stems :form :Flowers . 
	:Flowers :produce :Petals . # wrong but correct vocabulary
	:Leaves :errorPredicate :errorTerm .  #wrong because of vocabulary. 
}

#############################
## MATCHING
#############################

#### This is the generalised error of ommission query. 
## Diff between two graphs: Errors of omission
# e.g., Triples that are in teacher's map but not in the student's map. 

CONSTRUCT 
{?g :missed ?prop }
WHERE {
     ?prop rdf:subject ?sub ; 
          rdf:predicate ?pred ; 
          rdf:object ?obj . 
    GRAPH ?g {?s ?p ?o} . 
	FILTER NOT EXISTS {GRAPH ?g {?sub ?pred ?obj}}
  }
  

## Error of commission type A:
# List Wrong propositions.  


SELECT ?g ?s ?p ?o 
WHERE {
  GRAPH ?g {?s ?p ?o}   
  FILTER NOT EXISTS {
  ?prop rdf:subject ?s ; 
        rdf:predicate ?p ;
        rdf:object ?o.
  }
 }

## Error of commission type A:
# add a statement about wrong propositions. 
# To find out which ones are wrong see above. 

INSERT  {?g :errorOfCommission :Type1}
# CONSTRUCT {?g :errorOfCommission :Type1} 
WHERE {
 GRAPH ?g {?s ?p ?o} . 
 FILTER NOT EXISTS {
  ?prop rdf:subject ?s ; 
        rdf:predicate ?p ;
        rdf:object ?o.}

}

## Find Error of commission type B:
# Finds any single term not used in the teacher map. 
# That is: a differnt vocabulary. 

SELECT ?g ?s ?p ?o 
WHERE {
  {
  GRAPH ?g {?s ?p ?o}   
   MINUS {?prop rdf:object ?o}
  }
 UNION 
  {
  GRAPH ?g {?s ?p ?o}   
   MINUS {?prop rdf:predicate ?p}
  }
 UNION 
  {
  GRAPH ?g {?s ?p ?o}   
   MINUS {?prop rdf:subject ?s}
  }
  }


## Insert Error of commission Type B: 


INSERT {?g :error :ErrorOfCommissionB}
# CONSTRUCT {?g :error :ErrorOfCommissionB}
WHERE {
  {
  GRAPH ?g {?s ?p ?o}   
   MINUS {?prop rdf:object ?o}
  }
 UNION 
  {
  GRAPH ?g {?s ?p ?o}   
   MINUS {?prop rdf:predicate ?p}
  }
 UNION 
  {
  GRAPH ?g {?s ?p ?o}   
   MINUS {?prop rdf:subject ?s}
  }
  }

#############################
## SCORING
#############################

## Scoring model 1 
# Errors of omission only 
# Show all misses a and their weight by student 

SELECT ?student ?prop ?weight 
WHERE {
  ?student :missed ?prop . 
  ?statement :proposition ?prop . 
  ?statement :weight ?weight .   
  }
ORDER BY ?student

# Now sum them up. 

## Scoring model 1
# Errors of omission only.
# The higher the score the more ommissions (weighted). 
# Needs to be generalised so weight if not specified is 1 by default. 

SELECT ?student (SUM(xsd:decimal(?weight)) as ?score) 
WHERE {
  ?student :missed ?prop . 
  ?statement :proposition ?prop . 
  ?statement :weight ?weight .   
  }
GROUP BY ?student





