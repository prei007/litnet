# concept mapping demonstration
# This is written in TRIG. 
# https://www.w3.org/TR/trig/#sec-graph-statements

@prefix : <http://example.net/> .

#### Data 1: State of matter
# Students A-C  only specify one third of the goal map. 

:StudentA {
	:Gas :condensesTo :Liquid . 
	:Liquid :boilsTo :Gas . 
}

:StudentB {
	:Solid :sublimatesTo :Gas . 
	:Gas :depositsTo :Solid. 
}

:StudentC {
	:Solid :meltsTo :Liquid . 
	:Liquid :freezesTo :Solid. 
}

# Student D knows a bit about all three but not all. 

:StudentD {
	:Gas :condensesTo :Liquid . 
	:Solid :sublimatesTo :Gas . 
	:Solid :meltsTo :Liquid .
}

# Student E added a relation that is not in the teacher graph, plus two that are. 

:StudentE {
	:Gas :condensesTo :Liquid . 
	:Solid :errorRelation :Gas . 
	:Solid :meltsTo :Liquid .
}


# The full  teacher (or goal)  model. 

:Teacher {
	:Gas :condensesTo :Liquid . 
	:Liquid :boilsTo :Gas . 
	:Solid :sublimatesTo :Gas . 
	:Gas :depositsTo :Solid.  
	:Solid :meltsTo :Liquid . 
	:Liquid :freezesTo :Solid.
}



#####################
## Queries
#####################

# show all quads

SELECT ?g ?s ?p ?o  WHERE {
   GRAPH ?g { ?s ?p ?o }  
   }
ORDER BY ?g

# Find graphs that have a specific relation.
# Based on the data above, matches A, D, and E. 

SELECT ?g  WHERE {
	GRAPH ?g {:Gas :condensesTo :Liquid.} 
 }

# Shows the graphs (if any) that do have the specified relation. 

SELECT DISTINCT ?g  WHERE {
	GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {:Gas :condensesTo :Liquid.}
      }
 }
 
## Diff between two graphs 
# Triples that are in B but not in A. 


SELECT ?s ?p ?o ?g WHERE {
   GRAPH :StudentA { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :StudentB { ?s ?p ?o }}
  }

## Errors of ommission. 
# Shows the graphs (if any) that do not have the relation. 
# This is the only way I can come up with to test for 
# omissions. The elegant of full graph comparison does not work. 
# Use case wise, this is useful for finding patterns of omissions. 

SELECT  DISTINCT ?g  WHERE {
  {GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {GRAPH ?g {:Gas :condensesTo :Liquid.}}
      }
  UNION 
  {GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {GRAPH ?g {:Solid :sublimatesTo :Gas.}}
      }
  }
  

## Diff between two graphs: Errors of commission
# Triples that are in the student map but not the teacher map
# Student E has an superfluos relation in his map. 

SELECT ?s ?p ?o ?g WHERE {
   GRAPH :StudentE { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :Teacher { ?s ?p ?o }}
  }

# generalized commission error match: 

SELECT * WHERE {
   GRAPH ?g { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :Teacher { ?s ?p ?o }}
  }

  
# If we don't care about the particular triples, we can use an ASK query to check whether any exist, without finding out what they are. For instance,

###### Scaffolding queries  


# If a student is clueless about what to link to Gas,  
# offer them a first link. 

SELECT  ?s ?p ?o  WHERE {
  {GRAPH :Teacher {  :Liquid ?p ?o }  
     BIND ("Liquid"  as ?s) 
      }

  }
LIMIT 1

# If a student is clueless about what to say about Liquid,  
# offer them all or some (use Limit) predicates. 


SELECT  ?s ?p   WHERE {
  {GRAPH :Teacher {  :Liquid ?p ?o }  
     BIND ("Liquid"  as ?s) 
      }

  }
  
# In general, the LIMIT function provides an simple way to realize 
# increasing help levels - return first 1, then 2, then all parts of 
# the normative solution. 

##### Data 2: plants

# This does not work as it does not form a proper graph. 
:Teacher {
	:T01 :proposition [:Plants :havePart :Roots] ;
		:weight "1" . 
}

# A better idea is to describe the correct network and add meta data to it. 
# The below is correct. Note that it uses RDF Reification to keep things clean. 
# https://www.w3.org/TR/rdf-schema/#ch_reificationvocab


PREFIX : <http://example.net/> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 

:T01 :proposition :P01 ;
		:isa :Hierarchy ; 
		:weight "1" .
		
:P01 rdf:subject :Plants ;
	 rdf:predicate :havePart ; 
     rdf:object :Roots . 
		
:T02 :proposition :P02 ;
		:isa :Hierarchy ; 
		:weight "1" . 
:P02    rdf:subject :Plants ;
		rdf:predicate :havePart ; 
		rdf:object :Leaves . 
		
:T03 :proposition :P03 ;
		:isa :Hierarchy ; 
		:weight "1" . 
:P03 rdf:subject :Plants ;
		rdf:predicate :havePart ; 
		rdf:object :Stems . 
		
:T04 :proposition :P04 ; 
		:weight "1" . 
:P04 rdf:subject :Stems ;
		rdf:predicate :form ; 
		rdf:object :Flowers .
		
:T05 :proposition :P05 ; 
		:weight "1" . 
:P05 rdf:subject :Flowers ;
		rdf:predicate :produce ; 
		rdf:object :Seeds .
		
:T06 :proposition :P06 ; 
		:isa :BridgingRelation ; 
		:weight "2" . 
:P06 rdf:subject :Seeds ;
		rdf:predicate :store ; 
		rdf:object :Food .
		
:T07 :proposition :P07 ; 
		:weight "1" . 
:P07 rdf:subject :Flowers ;
		rdf:predicate :mayHave ; 
		rdf:object :Petals .
		
:T08 :proposition :P08 ; 
		:weight "1" . 
:P08 rdf:subject :Petals ;
		rdf:predicate :mayHave ; 
		rdf:object :Color .
		
:T09 :proposition :P09 ; 
		:weight "1". 
:P09 rdf:subject :Leaves ;
		rdf:predicate :areUsually ; 
		rdf:object :Green .
		
:T10 :proposition :P10 ; 
		:isa :BridgingRelation ;  # It's only a bridge if the Stems relation is realised. 
		:weight "2". 
:P10 rdf:subject :Leaves ;
		rdf:predicate :produce ; 
		rdf:object :Food .
		

:StudentA {
	:Plants :havePart :Leaves . 
	:Leaves :areUsually :Green . 
}


:StudentB {
	:Plants :havePart :Leaves . 
	:Plants :havePart :Roots .
	:Leaves :produce :Food.  
}

:StudentC {
	:Plants :havePart :Leaves . 
	:Plants :havePart :Roots .
	:Plants :havePart :Stems . 
	:Stems :form :Flowers . 
	:Flowers :produce :Seeds . 
	:Seeds :store :Food .  
}

#### And here is the generalised error of ommission query!!!
## Diff between two graphs: Errors of omission
# Triples that are in teacher's map but not in the student's map. 

CONSTRUCT 
{?g :missed ?prop }
WHERE {
     ?prop rdf:subject ?sub ; 
          rdf:predicate ?pred ; 
          rdf:object ?obj . 
    GRAPH ?g {?s ?p ?o} . 
	FILTER NOT EXISTS {GRAPH ?g {?sub ?pred ?obj}}
  }
  
  











