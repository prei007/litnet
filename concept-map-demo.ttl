# concept mapping demonstration
# This is written in TRIG. 
# https://www.w3.org/TR/trig/#sec-graph-statements

@prefix : <http://example.net/> .

#### Data 
# Students A-C  only specify one third of the goal map. 

:StudentA {
	:Gas :condensesTo :Liquid . 
	:Liquid :boilsTo :Gas . 
}

:StudentB {
	:Solid :sublimatesTo :Gas . 
	:Gas :depositsTo :Solid. 
}

:StudentC {
	:Solid :meltsTo :Liquid . 
	:Liquid :freezesTo :Solid. 
}

# Student D knows a bit about all three but not all. 

:StudentD {
	:Gas :condensesTo :Liquid . 
	:Solid :sublimatesTo :Gas . 
	:Solid :meltsTo :Liquid .
}

# Student E added a relation that is not in the teacher graph, plus two that are. 

:StudentE {
	:Gas :condensesTo :Liquid . 
	:Solid :errorRelation :Gas . 
	:Solid :meltsTo :Liquid .
}


# The full  teacher (or goal)  model. 

:Teacher {
	:Gas :condensesTo :Liquid . 
	:Liquid :boilsTo :Gas . 
	:Solid :sublimatesTo :Gas . 
	:Gas :depositsTo :Solid.  
	:Solid :meltsTo :Liquid . 
	:Liquid :freezesTo :Solid.
}



#####################
## Queries
#####################

# show all quads

SELECT ?g ?s ?p ?o  WHERE {
   GRAPH ?g { ?s ?p ?o }  
   }
ORDER BY ?g

# Find graphs that have a specific relation.
# Based on the data above, matches A, D, and E. 

SELECT ?g  WHERE {
	GRAPH ?g {:Gas :condensesTo :Liquid.} 
 }

# Shows the graphs (if any) that do have the specified relation. 

SELECT DISTINCT ?g  WHERE {
	GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {:Gas :condensesTo :Liquid.}
      }
 }
 
## Diff between two graphs 
# Triples that are in B but not in A. 


SELECT ?s ?p ?o ?g WHERE {
   GRAPH :StudentA { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :StudentB { ?s ?p ?o }}
  }

## Errors of ommission. 
# Shows the graphs (if any) that do not have the relation. 
# This is the only way I can come up with to test for 
# omissions. The elegant of full graph comparison does not work. 
# Use case wise, this is useful for finding patterns of omissions. 

SELECT  DISTINCT ?g  WHERE {
  {GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {GRAPH ?g {:Gas :condensesTo :Liquid.}}
      }
  UNION 
  {GRAPH ?g {  ?s ?p ?o }  
      FILTER NOT EXISTS {GRAPH ?g {:Solid :sublimatesTo :Gas.}}
      }
  }
  

## Diff between two graphs: Errors of commission
# Triples that are in the student map but not the teacher map
# Student E has an superfluos relation in his map. 

SELECT ?s ?p ?o ?g WHERE {
   GRAPH :StudentE { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :Teacher { ?s ?p ?o }}
  }

# generalized commission error match: 

SELECT * WHERE {
   GRAPH ?g { ?s ?p ?o } 
   	FILTER NOT EXISTS {GRAPH :Teacher { ?s ?p ?o }}
  }

  
# If we don't care about the particular triples, we can use an ASK query to check whether any exist, without finding out what they are. For instance,

###### Scaffolding queries


# If a student is clueless about what to link to Gas,  
# offer them a first link. 

SELECT  ?s ?p ?o  WHERE {
  {GRAPH :Teacher {  :Liquid ?p ?o }  
     BIND ("Liquid"  as ?s) 
      }

  }
LIMIT 1

# If a student is clueless about what to say about Liquid,  
# offer them all or some (use Limit) predicates. 


SELECT  ?s ?p   WHERE {
  {GRAPH :Teacher {  :Liquid ?p ?o }  
     BIND ("Liquid"  as ?s) 
      }

  }
  
# In general, the LIMIT function provides an simple way to realize 
# increasing help levels - return first 1, then 2, then all parts of 
# the normative solution. 


